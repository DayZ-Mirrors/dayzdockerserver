#!/usr/bin/env bash

source /files/dz-common

# Server container base directories
SERVER_PROFILE="/profiles"

mkdir -p ${SERVER_PROFILE}/battleye

# Server configuration file
SERVER_CFG_FILE="serverDZ.cfg"
SERVER_CFG_DST="${SERVER_PROFILE}/${SERVER_CFG_FILE}"
SERVER_CFG_SRC="${CFG_SRC_FILES}/${SERVER_CFG_FILE}"

# Command line parameters except mod, as that is handled separately.
parameters="-config=${SERVER_CFG_DST} -port=${port} -freezecheck -BEpath=${SERVER_PROFILE}/battleye -profiles=${SERVER_PROFILE} -nologs"

# Used to check if dayZ is installed
SERVER_INSTALL_FILE="${SERVER_FILES}/DayZServer"

# Workshop. This file will store metadata about what mods are in use in this server instance
WORKSHOP_CFG="${HOME}/workshop.cfg"
if [ ! -f "${WORKSHOP_CFG}" ]
then
	touch "${WORKSHOP_CFG}"
fi

INSTALLED_MODS="${SERVER_FILES}/workshop.cfg"

# An array to store Workshop items. Each element contains the mod's ID, name, and state (active or not).
declare -a workshopID
workshopfolder="${SERVER_FILES}/steamapps/workshop/content/${release_client_appid}"

# Backups
BACKUP_DIR="${HOME}/backup"
if [ ! -d "${BACKUP_DIR}" ]
then
	mkdir -p "${BACKUP_DIR}"
fi

# Functions

# Usage
usage(){
  echo -e "
${red}Bad option or arguments! ${yellow}${*}${default}

Usage: ${green}$(basename $0)${yellow} option [ arg1 [ arg2 ] ]

Options and arguments:

  a|activate id - Activate an installed DayZ Workshop items by id or index
  b|backup - Backup the mission storage files in all mission directories
  c|config - Update the internal serverDZ.cfg file from files/serverDZ.cfg on the host. Presents a unified diff if the internal file doesn't match the host file
  d|deactivate id - Deactivate an installed DayZ Workshop items by id or index - Keeps the mod files but excludes it from the mod parameter
  f|force - Forcibly kill the server. Use only as a last resort if the server won't shut down
  l|list - List Workshop items and their details
  n|rcon - Connect to the server using a python RCON client
  restart - Restart the server without restarting the container
  s|status - Shows the server's status: Running, uptime, mods, parameters, mod parameter, etc.
  stop - Stop the server
${default}"
  exit 1
}

# Manage the mod symlink
symlink(){
	W=${1}
	ID=${2}
	NAME=${3}
	if [ ! -L "${SERVER_FILES}/@${NAME}" ] && [[ ${W} = 1 ]]
	then
		ln -sv ${workshopfolder}/${ID} "${SERVER_FILES}/@${NAME}"
	elif [[ "${W}" = "0" ]]
	then
		rm -vf "${SERVER_FILES}/@${NAME}"
	fi
}

# Make sure to clean up and report on exit, as these files remain in the container's volume
report() {
	rm -f /tmp/mod_command_line /tmp/parameters
	echo
	echo -e "${yellow}========================================== error.log =========================================="
	find "${SERVER_PROFILE}" -name error.log -exec head {} \; -exec tail -n 30 {} \; -exec rm -f {} \;
	echo
	echo -e "========================================== script*.log ========================================"
	find "${SERVER_PROFILE}" -name "script*.log" -exec head {} \; -exec tail -n 30 {} \; -exec rm -f {} \;
	echo
	echo -e "========================================== *.RPT =============================================="
	find "${SERVER_PROFILE}" -name "*.RPT" -exec ls -la {} \; -exec tail -n 30 {} \; -exec rm -f {} \;
	echo
	echo -e "========================================== End log ======================================${default}"
}

# Start the server in the foreground
start(){
	# Do the report on exit. Set here so that it only happens once we're starting the server, and not for other actions.
	trap '
		report
	' EXIT
	mod_cmd
	cd ${SERVER_FILES}
	# Run the server. Allow docker to restart the container if the script exits with a code other than 0. This is so we can
	# safely shut the container down without killing the server within.
	printf "[ ${green}DayZ${default} ] Server starting...\n"
	# Save the mod command line and parameters that were used to start the server, so status reflects the running server's
	# actual status with those
	echo ${mod_command_line} > /tmp/mod_command_line
	echo ${parameters} > /tmp/parameters
	./DayZServer ${mod_command_line} ${parameters}
	EXIT_CODE=$?
	if [ -f ${SERVER_FILES}/restart ]
	then
		rm -f ${SERVER_FILES}/restart
		EXIT_CODE=42
	fi
	printf "\n[ ${yellow}DayZ${default} ] Server exited. Exit code: ${EXIT_CODE}\n"
	exit ${EXIT_CODE}
}

# Restarts the server by forcing an exit code other than 0, causing docker to restart the container.
restart(){
	touch "${SERVER_FILES}/restart"
	echo "Restarting DayZ server..."
	kill -TERM $(pidof DayZServer)
}

# Stops the server cleanly and exits 0, which will stop the container.
stop(){
	echo "Stopping DayZ server..."
	kill -TERM $(pidof DayZServer)
}

# Forcibly kill the server, should it be necessary.
force(){
	echo "Forcibly stopping DayZ server..."
	kill -KILL $(pidof DayZServer)
}

# Handle any changes in the server config file by allowing them to be merged after viewing a diff.
config(){
	if ! diff -q "${SERVER_CFG_DST}" "${SERVER_CFG_SRC}"
	then
		echo "========================================================================="
		diff -Nau --color "${SERVER_CFG_DST}" "${SERVER_CFG_SRC}" | more
		echo "========================================================================="
		if prompt_yn "The new server configuration file differs from what's installed. Use it?"
		then
			echo "Updating the server configuration file"
			cp "${SERVER_CFG_SRC}" "${SERVER_CFG_DST}"
		else
			echo "NOT updating the server configuration file"
		fi
	else
		echo "No differences found between ${SERVER_CFG_SRC} and ${SERVER_CFG_DST}"
	fi
}

# Assemble the workshop variables
get_installed_mods(){
	mapfile -t installedModsID < "${INSTALLED_MODS}"
	workshoplist=""
	for i in "${installedModsID[@]}"
	do
		ID=$(echo ${i} | cut -d: -f1)
		workshoplist+=" +workshop_download_item "${release_client_appid}" "${ID}
	done
}

get_mods(){
	mapfile -t workshopID < "${WORKSHOP_CFG}"
	workshoplist=""
	for i in "${workshopID[@]}"
	do
		ID=$(echo ${i} | cut -d: -f1)
		workshoplist+=" +workshop_download_item "${release_client_appid}" "${ID}
	done
}

get_mod_id_by_index(){
	# If we were passed a valid mod id, just return it
	if [[ -d "${workshopdir}/${1}" ]]
	then
		echo ${1}
		return
	fi
	X=1
	# Loop over mod list
	for i in "${workshopID[@]}"
	do
		ID=$(echo ${i} | cut -d: -f1)
		if [[ ${X} = ${1} ]]
		then
			echo ${ID}
			return
		fi
		X=$((X+1))
	done
}

# Get mod name by ID or index
get_mod_name(){
	# Check for an ID
	if [ -d "${workshopfolder}/${1}" ]
	then
		ID=${1}
	else
		ID=$(get_mod_id_by_index ${1})
	fi
	if ! [ -d "${workshopfolder}/${ID}" ]
	then
		echo "Mod ID ${1} doesn't exist" >&2
		exit 1
	fi
	NAME=$(grep name ${workshopfolder}/${ID}/meta.cpp | cut -d '"' -f2 | sed -r 's/\s+//g')
	echo ${NAME}
}

# Activate / Deactivate a mod
activate(){
	W=${1}
	shift
	WW=""
	COLOR="${green}"
	if [[ ${W} = 0 ]]
	then
		WW="de"
		UU="un"
		COLOR="${red}"
	fi
	ID=$(get_mod_id_by_index ${1})
	MODNAME=$(get_mod_name ${1})
	# Toggle state or report nothing burger
	if [[ "${ACTIVE}" != "${W}" ]]
	then
		sed -i "${WORKSHOP_CFG}" -e "s/${ID}:${MODNAME}:[0-1]/${ID}:${MODNAME}:${W}/"
		echo -e "Mod id ${ID} - ${COLOR}${MODNAME}${default} ${WW}activated"
	else
		echo -e "Mod id ${ID} - ${COLOR}${MODNAME}${default} - is already ${WW}active"
	fi
	list
}

# List available mods
list(){
	get_installed_mods

	if [[ "${workshopID[@]}" = "" ]]
	then
		return
	fi
	X=1
	spaces="                        "
	echo -e "\n     ID         Name                      Active URL                                                                Size"
	echo "------------------------------------------------------------------------------------------------------------------------"
	for i in "${workshopID[@]}"
	do
		ID=$(echo ${i} | cut -d: -f1)
		NAME=$(echo ${i} | cut -d: -f2)
		ACTIVE=$(echo ${i} | cut -d: -f3)
		SIZE=$(du -sh ${SERVER_FILES}/steamapps/workshop/content/221100/${ID} | awk '{print $1}')
		if [[ ${ACTIVE} = "1" ]]
		then
			C="${green}"
		else
			C="${red}"
		fi
		printf "${C}%.3d  %s %.23s  %s %s      https://steamcommunity.com/sharedfiles/filedetails/?id=%s  %s${default}\n" ${X} ${ID} "${NAME}" "${spaces:${#NAME}+1}" ${ACTIVE} ${ID} ${SIZE}
		X=$((X+1))
	done
}

# Assemble the mod command line
mod_cmd(){
	mod_command_line=""
	for i in "${workshopID[@]}"
	do
		NAME=$(echo ${i} | cut -d: -f2)
		ACTIVE=$(echo ${i} | cut -d: -f3)
		if [[ ${ACTIVE} = "1" ]]
		then
			mod_command_line="${mod_command_line}@${NAME};"
		fi
	done
	if [[ ${mod_command_line} != "" ]]
	then
		mod_command_line='-mod='${mod_command_line::-1}
	fi
}

checkXML(){
	# See if we have a template for it
	if [ -f "/files/mods/${1}/types.env" ]
	then
		echo "Found a templatate for mod ID ${1}, merging..."
		source "/files/mods/${1}/types.env"
		for xml in CFGEVENTSPAWNS CFGSPAWNABLETYPES EVENTS TYPES
		do
			NAME=$(echo ${xml} | tr A-Z a-z)
			if echo ${!xml} | grep -q http
			then
				echo "${NAME} file is remote, downloading..."
				curl -o ${workshopfolder}/${1}/${NAME}.xml ${!xml}
			else
				echo "${NAME} file is in the mod, copying..."
				cp -vf ${!xml} ${workshopfolder}/${1}/${NAME}.xml
			fi
		done
#	else
		# See if this mod has a types.xml in the "standard" locations
#		for path in "${workshopfolder}/${1}/extras" "${workshopfolder}/${1}"
#		do
#			if [ -f "${path}/types.xml" ]
#			then
#				echo -n "The mod id ${1} has a types.xml: ${path}/types.xml. "
#				if [[ ${2} = "install" ]]
#				then
#					echo "Merging to missions..."
#				else
#					echo "Removing contents from missions..."
#				fi
#				/files/mods/types.sh ${1} ${2} ${path}/types.xml
#				break
#			fi
#		done
	fi
}

# Our internal RCON
rcon(){
	exec /usr/local/py3rcon/py3rcon.py --gui ~/py3rcon.config.json
}

# Display the status of everything
status(){
  loadconfig
	INSTALLED="${NO}"
	RUNNING="${NO}"

	# DayZ Server files installation
	if [ -f "${SERVER_INSTALL_FILE}" ]
	then
		INSTALLED="${YES}"
	fi
	# Running or not
	if pidof DayZServer > /dev/null
	then
		# Uptime
		D=$(date +%s)
		F=$(date +%s -r ${SERVER_PROFILE}/server_console.log)
		DAYS=$(( (${D} - ${F}) / 86400 ))
#		UPTIME=$(date --date="$(( ${D} - ${F} ))" +"${DAYS} days %H:%M:%S")
		UPTIME="${DAYS} days "$(date -d@$(($(date +%s) - $(date +%s -r ${SERVER_PROFILE}/server_console.log))) -u +"%H hours %M minutes %S seconds")

		RUNNING="${YES}\nUptime: ${green}${UPTIME}${default}"
		# Current parameters
		RUNNING="${RUNNING}\nRunning Parameters: $(cat /tmp/parameters)\nRunning mod parameter: $(cat /tmp/mod_command_line)"
	fi

	mod_cmd

	MAP="none"
	# Map name
	if [[ -f ${SERVER_CFG_DST} ]]
	then
		MAP=$(grep -E "template=" ${SERVER_CFG_DST} | grep -vE "^//")
	fi
	# Number of mods plus the list denoting on or off
	echo -ne "
Logged in to Steam: ${LOGGED_IN} ${ANONYMOUS}
Server files installed: ${INSTALLED}"
	if [[ "${INSTALLED}" = "${NO}" ]]
	then
		echo
		echo
		exit 0
	fi
	echo -ne "
Mods: "
	MODS=$(list)
	if [[ ${MODS} == "" ]]
	then
		echo -n "none"
	fi
	echo -e "${MODS}
Server running: ${RUNNING}
Working parameters: ${parameters}
Working mod parameter: ${mod_command_line}"
	if [[ "${INSTALLED}" = "${YES}" ]]
	then
		MAP=$(grep template ${SERVER_CFG_DST} | grep -v "^//" | cut -d= -f2 | cut -d\; -f1)
		echo "Map: ${MAP}"
	fi
}

backup(){
	cd "${SERVER_FILES}"/mpmissions
	DATE=$(date +'%Y-%m-%d-%H-%M-%S')
	for i in $(ls)
	do
		B="${BACKUP_DIR}/${DATE}/"
		echo "Backing up ${i} to ${B}..."
		mkdir -p ${B}
		cp -a "${i}" "${B}"
	done
}

# Capture the first argument and shift it off so we can pass $@ to every function
C=${1}
shift || {
	usage
}

get_mods

case "${C}" in
	a|activate)
		activate 1 "${@}"
		;;
	add)
		add "${@}"
		;;
	b|backup)
		backup "${@}"
		;;
	c|config)
		config "${@}"
		;;
	d|deactivate)
		activate 0 "${@}"
		;;
	f|force)
		force
		;;
	i|install)
		install "${@}"
		;;
	l|list)
		list "${@}"
		;;
	login)
		login "${@}"
		;;
	m|modupdate)
		modupdate "${@}"
		;;
	n|rcon)
		rcon "${@}"
		;;
	r|remove)
		remove "${@}"
		;;
	restart)
		restart "${@}"
		;;
	start)
		start "${@}"
		;;
	s|status)
		status "${@}"
		;;
	stop)
		stop "${@}"
		;;
	u|update)
		update "${@}"
		;;
	*)
		usage "$*"
	;;
esac
